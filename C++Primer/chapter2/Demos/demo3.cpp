#include<iostream>
using namespace std;
#include<string>

/*
 含有无符号类型的表达式

 当一个算术表达式中既有无符号数又有int值时，那么这个int值就会被转换为无符号数。
 把int转换为无符号数的过程和把int直接赋给无符号变量一样：
*/

int main3()
{
    unsigned u = 10;
    int i = -42;

    cout << "i + i = " << i + i << endl; //输出-84
    cout << "u + i = " << u + i << endl; //如果int占32位，输出4294967264
    //1.把负数转换为无符号数，类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。
    // 在32位的编译器上,unsigned int 的最大值为4294967295，再加上0，一共4294967296个整数，
    // 即32位：无符号数的模为4294967296，这个数加上计算的的负数即为输出结果。
    // 例如：-32 + 4294967296 = 4294967264

    //2.当从无符号数中减去一个值时，不管这个值是不是负数，我们都必须确保结果不能是一个负数。
    unsigned u1 = 42;
    unsigned u2 = 12;
    cout << "u1 - u2 = " << u1 - u2 << endl; //正确，输出32
    cout << "u2 - u1 = " << u2 - u1 << endl; //正确，不过，结果是取模后的值：4294967266（-30 + 4294967296）

    //3.在for循环中无符号数的注意点
    //需求：从10递减输出到1
    //for (unsigned u = 10; u >= 0; --u) {
    //    cout << u << endl; //错误。变量u永远不会小于0，循环条件一直成立。
    //}
    
    //用while进行改进。
    unsigned u3 = 11; //确定要输出的最大数，从比它大1的数开始
    while (u3 > 0) {
        --u3; //在循环内--u，这样最后一次迭代时就会输出0。又因为0不满足while循环的条件，循环终止。
        cout << u3 << endl;
    }

    system("pause");
    return 0;
}
